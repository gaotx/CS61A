---
layout: resource
title: Project 4 A Scheme Interpreter
---
<body style="font-family: Georgia,serif;">
    <h1 id="title-main">Project 4: A Scheme Interpreter</h1>

    <div id="haiku">
  
<blockquote><p><img src="money_tree.png" alt="Money Tree"></p>

<cite>
  Eval calls apply,<br>
  which just calls eval again!<br>
  When does it all end?
</cite></blockquote>

</div>

    <h2 id="table-of-contents">Table of Contents</h2>
    <ul>
  <li><a href="#introduction">Introduction</a></li>
  <ul>
  <li><a href="#logistics">Logistics</a></li>
  <li><a href="#details-of-scheme">Details of Scheme</a></li>
  <li><a href="#development">Development</a></li>
  <li><a href="#running-your-scheme-interpreter">Running Your Scheme Interpreter</a></li>
</ul>

  <li><a href="#part-i-the-reader">Part I: The Reader</a></li>
  <ul>
  <li><a href="#problem-1-1-pt">Problem 1 (1 pt)</a></li>
  <li><a href="#problem-2-2-pt">Problem 2 (2 pt)</a></li>
</ul>

  <li><a href="#part-ii-the-evaluator">Part II: The Evaluator</a></li>
  <ul>
  <li><a href="#some-core-functionality">Some Core Functionality</a></li>
  <ul>
  <li><a href="#problem-3-2-pt">Problem 3 (2 pt)</a></li>
  <li><a href="#problem-4-2-pt">Problem 4 (2 pt)</a></li>
  <li><a href="#problem-5a-1-pt">Problem 5A (1 pt)</a></li>
  <li><a href="#problem-6b-1-pt">Problem 6B (1 pt)</a></li>
</ul>

  <li><a href="#user-defined-procedures">User-Defined Procedures</a></li>
  <ul>
  <li><a href="#problem-7-2-pt">Problem 7 (2 pt)</a></li>
  <li><a href="#problem-8-2-pt">Problem 8 (2 pt)</a></li>
  <li><a href="#problem-9a-1-pt">Problem 9A (1 pt)</a></li>
  <li><a href="#problem-10-2-pt">Problem 10 (2 pt)</a></li>
  <li><a href="#problem-11b-1-pt">Problem 11B (1 pt)</a></li>
  <li><a href="#problem-12-2-pt">Problem 12 (2 pt)</a></li>
</ul>

  <li><a href="#special-forms">Special Forms</a></li>
  <ul>
  <li><a href="#problem-13a-1-pt">Problem 13A (1 pt)</a></li>
  <li><a href="#problem-14b-2-pt">Problem 14B (2 pt)</a></li>
  <li><a href="#problem-15a-1-pt">Problem 15A (1 pt)</a></li>
  <li><a href="#problem-16-2-pt">Problem 16 (2 pt)</a></li>
  <li><a href="#problem-17-2-pt">Problem 17 (2 pt)</a></li>
</ul>

</ul>

  <li><a href="#part-iii-write-some-scheme">Part III: Write Some Scheme</a></li>
  <ul>
  <li><a href="#problem-18-1-pt">Problem 18 (1 pt)</a></li>
  <li><a href="#problem-19-1-pt">Problem 19 (1 pt)</a></li>
  <li><a href="#problem-20-2-pt">Problem 20 (2 pt)</a></li>
  <li><a href="#problem-21-0-pt-optional">Problem 21 (0 pt; <em>optional</em>)</a></li>
</ul>

  <li><a href="#part-iv-extra">Part IV: Extra</a></li>
  <ul>
  <li><a href="#extra-credit-problem-22-2-pt">Extra Credit Problem 22 (2 pt)</a></li>
  <li><a href="#recursive-art-contest">Recursive Art Contest</a></li>
  <li><a href="#extra-challenge">Extra Challenge</a></li>
</ul>

</ul>


    


<h2 id="introduction">Introduction</h2>


<p>In this project, you will develop an interpreter for a subset of the Scheme
language. As you proceed, think about the issues that arise in the design of a
programming language; many quirks of languages are byproducts of implementation
decisions in interpreters and compilers. The subset of the language used in
this project is described in the <a href="http://composingprograms.com/pages/32-functional-programming.html">functional programming</a> section of
Composing Programs.</p>

<p>You will also implement some small programs in Scheme. Scheme is a simple but
powerful functional language. You should find that much of what you have
learned about Python transfers cleanly to Scheme as well as to other
programming languages. To learn more about Scheme, you can read <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">Structure and
Interpretation of Computer Programs</a> online for free. Examples from
Chapters 1 and 2 are included as test cases for this project. Language features
from Chapters 3, 4, and 5 are not part of this project, but of course you are
welcome to extend your interpreter to implement more of the language. Since we
only include a subset of the language, your interpreter will not exactly match
the behavior of other interpreters such as <a href="http://inst.eecs.berkeley.edu/~scheme">STk</a>.</p>

<p>The project concludes with an open-ended graphics contest that challenges you
to produce recursive images in only a few lines of Scheme. As an example, the
picture above abstractly depicts all the ways of making change for $0.50 using
U.S. currency. All flowers appear at the end of a branch with length 50. Small
angles in a branch indicate an additional coin, while large angles indicate a
new currency denomination. In the contest, you too will have the chance to
unleash your inner recursive artist.</p>

<p>This project includes several files, but all of your changes will be made to
the first four: <code>scheme.py</code>, <code>scheme_reader.py</code>, <code>questions.scm</code>, and
<code>tests.scm</code>. You can download all of the project code as a <a href="scheme.zip">zip
archive</a>, which contains the following files:</p>

<table cellpadding="10">
  <tbody><tr>
    <td><code>scheme.py</code></td>
    <td>The Scheme evaluator</td>
  </tr>

  <tr>
    <td><code>scheme_reader.py</code></td>
    <td>The Scheme syntactic analyzer</td>
  </tr>

  <tr>
    <td><code>questions.scm</code></td>
    <td>A collection of functions written in Scheme</td>
  </tr>

  <tr>
    <td><code>tests.scm</code></td>
    <td>A collection of test cases written in Scheme</td>
  </tr>

  <tr>
    <td><code>scheme_tokens.py</code></td>
    <td>A tokenizer for Scheme</td>
  </tr>

  <tr>
    <td><code>scheme_primitives.py</code></td>
    <td>Primitive Scheme procedures</td>
  </tr>

  <tr>
    <td><code>scheme_test.py</code></td>
    <td>A testing framework for Scheme</td>
  </tr>

  <tr>
    <td><code>buffer.py</code></td>
    <td>A buffer implementation</td>
  </tr>

  <tr>
    <td><code>ucb.py</code></td>
    <td>Utility functions for 61A</td>
  </tr>

  <tr>
    <td><code>ok</code></td>
    <td>Autograder software</td>
  </tr>

  <tr>
    <td><code>tests</code></td>
    <td>A directory of tests used by <code>ok</code></td>
  </tr>
</tbody></table>


<h3 id="logistics">Logistics</h3>


<p>You'll work in a team of two people, Partner A and Partner B. In each part, you
will do some of the work separately and some together with your partner. For
example, if a problem is marked 5A, then it is a solo problem for Partner A.
Both partners should read, think about, and understand the solution to all
questions. Feel free to help each other on the solo questions. If you choose to
work on the whole project alone, you must complete all questions yourself.</p>

<p>In Parts I and II, you will develop the interpreter in these stages:</p>

<ul>
  <li>Reading Scheme expressions</li>
  <li>Primitive procedure calls</li>
  <li>Symbol evaluation and definition</li>
  <li>Lambda expressions and procedure definition</li>
  <li>Calling user-defined procedures</li>
  <li>Evaluation of various special forms</li>
</ul>

<p>In Part III, you will implement Scheme procedures.</p>

<p>There are 27 possible correctness points and 3 composition points. The
composition score in this project will evaluate the clarity of your code and
<strong>your ability to write tests that verify the behavior of your interpreter</strong>.</p>

<p>Submit the project by running <code>python3 ok --submit</code>. Only partner A should
submit with this command.</p>

<p>In addition to submitting the project via this command, create a group on the
<a href="http://ok.cs61a.org">ok website</a>. A video walkthrough of this process is available
<a href="https://dl.dropboxusercontent.com/u/28511961/ok_groups.mp4">here</a>.</p>

<p>We also ask that you submit your final version through the homework submission
system by copying <code>scheme.py</code>, <code>scheme_reader.py</code>, <code>tests.scm</code>, and
<code>questions.scm</code> to your class account and running <code>submit proj4</code>. This
secondary submission will be used to resolve any issues with the <code>ok</code> system.</p>


<h3 id="details-of-scheme">Details of Scheme</h3>


<p><strong>Read-Eval-Print.</strong> The interpreter reads Scheme expressions, evaluates them,
and displays the results.</p>

<pre><code>scm&gt; 2
2
scm&gt; (((lambda (f) (lambda (x) (f f x)))
       (lambda (f k) (if (zero? k) 1 (* k (f f (- k 1)))))) 5)
120</code></pre>

<p>The starter code for your Scheme interpreter in <code>scheme.py</code> can successfully
evaluate the first expression above, since it consists of a single number. The
second (a computation of 5 factorial) will not work just yet.</p>

<p><strong>Load.</strong> Our <code>load</code> procedure differs from standard Scheme in that we use a
symbol for the file name. For example, to load <code>tests.scm</code>, evaluate the
following call expression.</p>

<pre><code>scm&gt; (load 'tests)</code></pre>

<p><strong>Symbols.</strong> Unlike some implementations of Scheme, in this project numbers and
boolean values cannot be used as symbols.  Also, symbols are always lowercased.
This is illustrated in the following example, which won't work until a little
bit later:</p>

<pre><code>scm&gt; (define 2 3)
Traceback (most recent call last):
  0 (#define 2 3)
Error: bad argument to define
scm&gt; 'Hello
hello</code></pre>

<p><strong>Turtle Graphics.</strong> In addition to standard Scheme procedures, we include
procedure calls to the Python <code>turtle</code> package. This will come in handy in Part
IV, for the contest.</p>

<p>You can read the <a href="http://docs.python.org/py3k/library/turtle.html">turtle module
documentation</a> online.</p>

<u>Note</u>: The <code>turtle</code> Python module may not be installed by default on your
personal computer. However, the <code>turtle</code> module is installed on the
instructional machines.  So, if you wish to create turtle graphics for this
project (i.e. for the contest), then you'll either need to setup <code>turtle</code> on
your personal computer or use university computers.


<h3 id="development">Development</h3>


<p><strong>Testing.</strong> The <code>tests.scm</code> file contains a long list of example Scheme
expressions and their expected values.</p>

<pre><code>(+ 1 2)
; expect 3
(/ 1 0)
; expect Error</code></pre>

<p>You can compare the output of your interpreter to the expected output by
running:</p>

<pre><code>python3 scheme_test.py</code></pre>

<p>For the example above, <code>scheme_test.py</code> will evaluate <code>(+ 1 2)</code> using your code
in <code>scheme.py</code>, then output a test failure if <code>3</code> is not returned as the value.
The second example tests for an error (but not the specific error message.</p>

<p>Only a small subset of tests are designated to run by default because
<code>tests.scm</code> contains an <code>(exit)</code> call near the beginning, which halts testing.
<strong>As you complete more of the project, you should move or remove this call</strong>.</p>

<p><em>Note</em>: your interpreter doesn't know how to <code>exit</code> until Problems 3 and 4 are
completed; all tests will run until then.</p>

<p><strong>Important</strong>: As you proceed in the project, add new tests to the top of
<code>tests.scm</code> to verify the behavior of your implementation. Your composition
score for this project will depend on whether or not you have tested your
implementation in ways that are different from the <code>ok</code> tests.</p>

<p>As always, you can run the doctests for the project:</p>

<pre><code>python3 -m doctest scheme.py scheme_reader.py</code></pre>

<p>We've included an autograder which includes tests for each question. You will
have to unlock some of the tests first before you can use them to test your
implementations. To unlock tests for question 1, run the following command from
your terminal:</p>

<pre><code>python3 ok -u -q 01</code></pre>

<p>Once you have unlocked the tests, you can run the tests for question 1 as
follows:</p>

<pre><code>python3 ok -q 01</code></pre>

<p>You can also invoke the autograder for all problems at once using:</p>

<pre><code>python3 ok</code></pre>

<p>The <code>tests</code> directory is used to store autograder tests, so <strong>make sure not to
modify it</strong>. You may lose all your unlocking progress if you do. If you need to
get a fresh copy, you can download the <a href="scheme.zip">zip archive</a> and copy it
over, but you will need to start unlocking from scratch.</p>

<p>If you have any problems logging in or communicating with the server, use the
<code>--local</code> flag to inhibit any server communication.</p>

<p><strong>Note that the tests we provide you through the autograder are not
comprehensive.</strong> To ensure that your interpreter is correct and bug-free, you
will have to add your own tests to <code>tests.scm</code>, and ensure that they cover as
many cases as possible.</p>

<p><strong>Debugging.</strong> If you're stuck, try using the <code>trace</code> decorator from the <code>ucb</code>
module to follow the path of execution in your interpreter.</p>

<p>You can also use <code>ok</code> to help with debugging, by adding the <code>-i</code> flag to start
an interactive session:</p>

<pre><code>python3 ok -q 1 -i</code></pre>

<p>If you get stuck, try this <a href="http://cs61a.org/debugging.html">guide to debugging</a>.</p>

<p><strong>Exceptions.</strong> As you develop your Scheme interpreter, you may find that Python
raises various uncaught exceptions when evaluating Scheme expressions. As a
result, your Scheme interpreter will halt. Some of these may be the results of
bugs in your program, and some may be useful indications of errors in user
programs. The former should be fixed (of course!) and the latter should be
handled, usually by raising a <code>SchemeError</code>. All <code>SchemeError</code> exceptions are
handled and printed as error messages by the <code>read_eval_print_loop</code> function in
<code>scheme.py</code>. Ideally, there should never be unhandled Python exceptions for any
input to your interpreter.</p>


<h3 id="running-your-scheme-interpreter">Running Your Scheme Interpreter</h3>


<p>To run your Scheme interpreter in an interactive session, type:</p>

<pre><code>python3 scheme.py</code></pre>

<p>You can use your Scheme interpreter to evaluate the expressions in an input file
by passing the file name as a command-line argument to <code>scheme.py</code>:</p>

<pre><code>python3 scheme.py tests.scm</code></pre>

<p>Currently, your Scheme interpreter can handle a few simple expressions, such as:</p>

<pre><code>scm&gt; 1
1
scm&gt; 42
42
scm&gt; #t
True</code></pre>

<p>To exit the Scheme interpreter, press either <code>Ctrl-c</code> or <code>Ctrl-d</code> or evaluate
the <code>exit</code> procedure (after completing questions 3 and 4):</p>

<pre><code>scm&gt; (exit)</code></pre>


<h2 id="part-i-the-reader">Part I: The Reader</h2>


<p>The function <code>scheme_read</code> in <code>scheme_reader.py</code> parses a <code>Buffer</code> (see
<code>buffer.py</code>) instance that returns valid Scheme tokens when its <code>current</code> and
<code>pop</code> methods are invoked. It returns the next full Scheme expression in the
<code>src</code> buffer, using this representation:</p>

<table border="1" align="center">
  <tbody><tr>
    <th>Scheme Data Type</th>
    <th>Our Internal Representation</th>
  </tr>

  <tr>
    <td>Numbers</td>
    <td>Python's built-in <code>int</code> and <code>float</code> data
    types.</td>
  </tr>

  <tr>
    <td>Symbols</td>
    <td>Python's built-in <code>string</code> data type.</td>
  </tr>

  <tr>
     <td>Booleans (<code>#t</code>, <code>#f</code>)</td>
     <td>Python's built-in <code>True</code>, <code>False</code> values.</td>
  </tr>

  <tr>
     <td>Pairs</td>
     <td>The <code>Pair</code> class, defined in
     <code>scheme_reader.py</code>.</td>
  </tr>

  <tr>
     <td><code>nil</code></td>
     <td>The <code>nil</code> object, defined in
     <code>scheme_reader.py</code>.</td>
  </tr>
</tbody></table>


<h3 id="problem-1-1-pt">Problem 1 (1 pt)</h3>

<p>Complete the <code>scheme_read</code> function in <code>scheme_reader.py</code> by adding support for
quotation. This function selects behavior based on the type of the next token:</p>

<ul>
  <li>If the next token in <code>src</code> is the string <code>"nil"</code>, return the <code>nil</code> object.
  <strong>(provided)</strong></li>
  <li>If the next token is not a delimiter, then it is self-evaluating. Return it.
  <strong>(provided)</strong></li>
  <li>If the current token is a single quote (such as the first character of
  <code>'bagel</code>), then return a quote special form (such as <code>(quote bagel)</code>).</li>
  <li>If the current token is a left parenthesis <code>"("</code>, return the result of
  <code>read_tail</code>. <strong>(provided)</strong></li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 1 -u
python3 ok -q 1 -i</code></pre>


<h3 id="problem-2-2-pt">Problem 2 (2 pt)</h3>

<p>Complete the <code>read_tail</code> function in <code>scheme_reader.py</code> by adding support for
dotted lists. A dotted list in Scheme is not necessarily a well-formed list, but
instead has an arbitrary <code>second</code> attribute that may be any Scheme value.</p>

<p>The <code>read_tail</code> function expects to read the rest of a list or dotted list,
assuming the open parenthesis of that list has already been popped by
<code>scheme_read</code>.</p>

<p>Consider the case of calling <code>scheme_read</code> on input "<code>(1 2 . 3)</code>". The
<code>read_tail</code> function will be called on the suffix "<code>1 2 . 3)</code>", which is</p>

<ul>
  <li>The pair consisting of the Scheme value <code>1</code> and the value of the tail "<code>2 .
  3)</code>", which is</li>
  <li>The pair consisting of the Scheme value <code>2</code> and the Scheme value <code>3</code>.</li>
</ul>

<p>Thus, <code>read_tail</code> would return <code>Pair(1, Pair(2, 3))</code>.</p>

<p><em>Hint</em>: In order to verify that only one element follows a dot, after
encountering a <code>'.'</code>, read one additional expression and then
check to see that a closing parenthesis follows.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 2 -u
python3 ok -q 2 -i</code></pre>

<p>You should also run the doctests for <code>scheme_reader.py</code> and test your parser
interactively by running <code>python3 scheme_reader.py</code>. Every time you type in a
value into the prompt, both the <code>str</code> and <code>repr</code> values of the parsed expression
are printed.</p>

<pre><code>read&gt; 42
str : 42
repr: 42
read&gt; '(1 2 3)
str : (quote (1 2 3))
repr: Pair('quote', Pair(Pair(1, Pair(2, Pair(3, nil))), nil))
read&gt; nil
str : ()
repr: nil
read&gt; '()
str : (quote ())
repr: Pair('quote', Pair(nil, nil))
read&gt; (1 (2 3) (4 (5)))
str : (1 (2 3) (4 (5)))
repr: Pair(1, Pair(Pair(2, Pair(3, nil)), Pair(Pair(4, Pair(Pair(5, nil), nil)), nil)))
read&gt; (1 (9 8) . 7)
str : (1 (9 8) . 7)
repr: Pair(1, Pair(Pair(9, Pair(8, nil)), 7))
read&gt; (hi there . (cs . (student)))
str : (hi there cs student)
repr: Pair('hi', Pair('there', Pair('cs', Pair('student', nil))))</code></pre>


<h2 id="part-ii-the-evaluator">Part II: The Evaluator</h2>


<p><strong>All further changes to the interpreter will be made in <code>scheme.py</code>. For each
question, add a few tests to the top of <code>tests.scm</code> to verify the behavior of
your implementation.</strong></p>

<p>In the implementation given to you, the <code>scheme_eval</code> function is complete, but
most of the functions or methods it uses are not implemented. In fact, the
evaluator can only evaluate self-evaluating expressions: numbers, booleans, and
<code>nil</code>.</p>


<h3 id="some-core-functionality">Some Core Functionality</h3>



<h4 id="problem-3-2-pt">Problem 3 (2 pt)</h4>

<p>Implement <code>apply_primitive</code>, which is called by <code>scheme_apply</code>. Primitive
procedures are applied by calling a corresponding Python function that
implements the procedure.</p>

<p>Scheme primitive procedures are represented as instances of the
<code>PrimitiveProcedure</code> class, defined in <code>scheme_primitives.py</code>. A
<code>PrimitiveProcedure</code> has two instance attributes:</p>

<ul>
  <li><code>fn</code> is the <strong>Python</strong> function that implements the primitive Scheme
  procedure.</li>
  <li><code>use_env</code> is a boolean flag that indicates whether or not this primitive
  procedure will expect the current environment to be passed in as the last
  argument. The environment is required, for instance, to implement the primitive
  <code>eval</code> procedure.</li>
</ul>

<p>To see a list of all Scheme primitive procedures used in the project, look in
the <code>scheme_primitives.py</code> file. Any function decorated with <code>@primitive</code> will
be added to the globally-defined <code>_PRIMITIVES</code> list.</p>

<p>The <code>apply_primitive</code> function takes a <code>PrimitiveProcedure</code> instance, a Scheme
list of argument values, and the current environment.  Your implementation
should:</p>

<ul>
  <li>Convert the Scheme list to a Python list of arguments <strong>(provided)</strong>.</li>
  <li>If the <code>procedure.use_env</code> is <code>True</code>, then add the current environment <code>env</code>
  as the last argument.</li>
  <li>Call <code>procedure.fn</code> on those arguments (<em>Hint</em>: use * notation).</li>
  <li>If calling the function results in a <code>TypeError</code> exception being thrown, then
  raise a <code>SchemeError</code> instead.</li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 3 -u
python3 ok -q 3 -i</code></pre>

<p>The doctest for <code>apply_primitive</code> should now pass. However, your Scheme
interpreter will still not be able to apply primitive procedures, because your
Scheme interpreter still doesn't know how to look up the values for built-in
symbols (such as <code>+</code>, <code>*</code>, and <code>car</code>). Let's fix that.</p>


<h4 id="problem-4-2-pt">Problem 4 (2 pt)</h4>

<p>Implement the <code>lookup</code> method of the <code>Frame</code> class. It takes a symbol (Python
string) and returns the value bound to that name in the first <code>Frame</code> of the
environment in which that name is found.  A <code>Frame</code> represents an environment
via two instance attributes:</p>

<ul>
  <li><code>bindings</code> is a dictionary that maps Scheme symbol keys (represented as
  Python strings) to Scheme values.</li>
  <li><code>parent</code> is the parent <code>Frame</code> instance. The parent of the Global Frame is
  <code>None</code>.</li>
</ul>

<p>Your <code>lookup</code> implementation should:</p>

<ul>
  <li>Return the value of the symbol in <code>self.bindings</code> if it exists.</li>
  <li>Otherwise, <code>lookup</code> that symbol in the <code>parent</code> if the <code>parent</code> exists.</li>
  <li>Otherwise, raise a <code>SchemeError</code>. <strong>(provided)</strong></li>
</ul>

<p>After you complete this problem, you should be able to evaluate primitive
procedure calls, giving you the functionality of the Calculator language and
more.</p>

<pre><code>scm&gt; +
#[primitive]
scm&gt; (+ 1 2)
3
scm&gt; (* 3 4 (- 5 2) 1)
36
scm&gt; (odd? 31)
True</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 4 -u
python3 ok -q 4 -i</code></pre>


<h4 id="problem-5a-1-pt">Problem 5A (1 pt)</h4>

<p>There are two missing parts in the <code>do_define_form</code> function, which handles the
<code>(define&nbsp;...)</code> special forms.  Implement <strong>just the first part</strong>, which binds
names to values but does not create new procedures.  <code>do_define_form</code> should
return the name after performing the binding.</p>

<pre><code>scm&gt; (define tau (* 2 3.1415926))
tau</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 5 -u
python3 ok -q 5 -i</code></pre>

<p>You should now be able to give names to values and evaluate symbols to those
values.</p>

<pre><code>scm&gt; (define x 15)
x
scm&gt; (define y (* 2 x))
y
scm&gt; y
30
scm&gt; (+ y (* y 2) 1)
91
scm&gt; (define x 20)
x
scm&gt; x
20</code></pre>


<h4 id="problem-6b-1-pt">Problem 6B (1 pt)</h4>

<p>Implement the <code>do_quote_form</code> function, which evaluates the <code>quote</code> special
form.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 6 -u
python3 ok -q 6 -i</code></pre>

<p>You should now be able to evaluate quoted expressions.</p>

<pre><code>scm&gt; 'hello
hello
scm&gt; '(1 . 2)
(1 . 2)
scm&gt; '(1 (2 three . (4 . 5)))
(1 (2 three 4 . 5))
scm&gt; (car '(a b))
a
scm&gt; (eval (cons 'car '('(1 2))))
1</code></pre>

<p>At this point in the project, your Scheme interpreter should be be able to
support the following features:</p>

<ul>
  <li>Evaluate atoms, which include numbers, booleans, nil, and symbols,</li>
  <li>Evaluate the <code>quote</code> special form,</li>
  <li>Evaluate lists,</li>
  <li>Define symbols, and</li>
  <li>Call primitive procedures, for example evaluating <code>(+ (- 4 2) 5)</code>.</li>
</ul>


<h3 id="user-defined-procedures">User-Defined Procedures</h3>


<p>User-defined procedures are represented as instances of the <code>LambdaProcedure</code>
class, defined in <code>scheme.py</code>. A <code>LambdaProcedure</code> instance has three instance
attributes:</p>

<ul>
  <li><code>formals</code> is a Scheme list of the formal parameters (symbols) that name the
  arguments of the procedure.</li>
  <li><code>body</code> is a single Scheme expression; the body of the procedure.</li>
  <li><code>env</code> is the environment in which the procedure was <strong>defined</strong>.</li>
</ul>


<h4 id="problem-7-2-pt">Problem 7 (2 pt)</h4>

<p>First, implement the <code>begin</code> special form, which includes a list of one or more
sub-expressions that are each evaluated in order.  The value of the <code>begin</code>
expression is the value of the final sub-expression.</p>

<pre><code>scm&gt; (begin (+ 2 3) (+ 5 6))
11
scm&gt; (define x (begin (display 3) (newline) (+ 2 3)))
3
x
scm&gt; (+ x 3)
8
scm&gt; (begin (print 3) '(+ 2 3))
3
(+ 2 3)</code></pre>

<p><em>Hint</em>: When <code>scheme_eval</code> evaluates one of the <code>LOGICAL_FORMS</code> in
<code>scheme.py</code>, it calls <code>scheme_eval</code> on the <strong>returned value</strong>. Take care that
your Scheme interpreter doesn't inadvertently call <code>scheme_eval</code> on the same
value twice, or else you might have the following incorrect behavior:</p>

<pre><code>scm&gt; (begin 30 'hello)
Error: unknown identifier: hello</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 7 -u
python3 ok -q 7 -i</code></pre>


<h4 id="problem-8-2-pt">Problem 8 (2 pt)</h4>

<p>Implement the <code>do_lambda_form</code> method, which creates <code>LambdaProcedure</code> instances
by evaluating <code>lambda</code> expressions. While you cannot call a user-defined
procedure yet, you can verify that you have read the procedure correctly by
evaluating a lambda expression:</p>

<pre><code>scm&gt; (lambda (x y) (+ x y))
(lambda (x y) (+ x y))</code></pre>

<p>In Scheme, it is legal to have function bodies with more than one expression.
In order to implement this feature, your <code>do_lambda_form</code> should detect when
the body of a lambda expression contains multiple expressions. If so, then
<code>do_lambda_form</code> should place those expressions inside of a <code>(begin ...)</code> form,
and use that <code>begin</code> expression as the body:</p>

<pre><code>scm&gt; (lambda (y) (print y) (* y 2))
(lambda (y) (begin (print y) (* y 2)))</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 8 -u
python3 ok -q 8 -i</code></pre>


<h4 id="problem-9a-1-pt">Problem 9A (1 pt)</h4>

<p>Currently, your Scheme interpreter is able to define user-defined procedures in
the following manner:</p>

<pre><code>scm&gt; (define f (lambda (x) (* x 2)))
f</code></pre>

<p>However, we'd like to be able to use the shorthand form of defining procedures:</p>

<pre><code>scm&gt; (define (f x) (* x 2))
f</code></pre>

<p>Modify the <code>do_define_form</code> function so that it correctly handles the shorthand
procedure definition form above. Make sure that it can handle multi-expression
bodies.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 9 -u
python3 ok -q 9 -i</code></pre>

<p>You should now find that defined procedures evaluate to lambda procedures.</p>

<pre><code>scm&gt; (define (square x) (* x x))
square
scm&gt; square
(lambda (x) (* x x))</code></pre>


<h4 id="problem-10-2-pt">Problem 10 (2 pt)</h4>

<p>Implement the <code>make_call_frame</code> method of the <code>Frame</code> class, which:</p>

<ul>
  <li>Creates a new <code>Frame</code> instance, the parent of which is <code>self</code>. <strong>(provided)</strong></li>
  <li>Binds formal parameters to their corresponding argument values.</li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 10 -u
python3 ok -q 10 -i</code></pre>


<h4 id="problem-11b-1-pt">Problem 11B (1 pt)</h4>

<p>Implement the <code>check_formals</code> function to raise an error whenever the Scheme
list of formal parameters passed to it is invalid.  Raise a <code>SchemeError</code> if
the list of <code>formals</code> is not a well-formed list of symbols or if any symbol is
repeated.</p>

<p><em>Hint</em>: The <code>scheme_symbolp</code> function in <code>scheme_primitives.py</code> returns whether
a value is a Scheme symbol.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 11 -u
python3 ok -q 11 -i</code></pre>


<h4 id="problem-12-2-pt">Problem 12 (2 pt)</h4>

<p>Implement <code>scheme_apply</code> to correctly apply user-defined <code>LambdaProcedure</code>
instances. (The case for <code>MuProcedure</code> is handled later in the project). It
should:</p>

<ul>
  <li>Create a new <code>Frame</code>, with all formal parameters bound to their argument
  values and the correct parent <code>Frame</code>,</li>
  <li>Evaluate the <code>body</code> of <code>procedure</code> in the environment represented by this new
  frame, and</li>
  <li>Return the value of calling <code>procedure</code>.</li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 12 -u
python3 ok -q 12 -i</code></pre>

<p>After you complete <code>scheme_apply</code>, user-defined functions (and lambda
functions) should work in your Scheme interpreter.  Now is an excellent time to
revisit the tests in <code>tests.scm</code> and ensure that you pass the ones that involve
definition (Sections 1.1.2 and 1.1.4).  <strong>You should also add additional tests
of your own at the top of <code>tests.scm</code> to verify that your interpreter is
behaving as you expect.</strong></p>


<h3 id="special-forms">Special Forms</h3>


<p>Logical special forms include <code>if</code>, <code>and</code>, <code>or</code>, and <code>cond</code>. These expressions
are special because not all of their sub-expressions may be evaluated.</p>

<p>In Scheme, only <code>#f</code> is a false value. All other values are true values. You
can test whether a value is a true value or a false value using the provided
Python functions <code>scheme_true</code> and <code>scheme_false</code>, defined in
<code>scheme_primitives.py</code>. Note that, in our interpreter, like in STk, <code>false</code> and
<code>False</code> can be used in place of <code>#f</code>. Similarly, <code>true</code> and <code>True</code> can be used
in place of <code>#t</code>.</p>


<h4 id="problem-13a-1-pt">Problem 13A (1 pt)</h4>

<p>Implement <code>do_if_form</code> so that <code>if</code> expressions are evaluated correctly. This
function should return either the second (consequent) or third (alternative)
expression of the <code>if</code> expression, depending on the value of the first
(predicate) expression.</p>

<pre><code>scm&gt; (if (= 4 2) #t #f)
False
scm&gt; (if (= 4 4) (* 1 2) (+ 3 4))
2</code></pre>

<p>It is legal to pass in just two expressions to the <code>if</code> special form. In this
case, you should return the second expression if the first expression evaluates
to a true value. Otherwise, return the special <code>okay</code> value, which represents an
undefined value.</p>

<pre><code>scm&gt; (if (= 4 2) #t)
okay</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 13 -u
python3 ok -q 13 -i</code></pre>


<h4 id="problem-14b-2-pt">Problem 14B (2 pt)</h4>

<p>Implement <code>do_and_form</code> and <code>do_or_form</code> so that <code>and</code> and <code>or</code> expressions are
evaluated correctly.</p>

<p>The logical forms <code>and</code> and <code>or</code> are <em>short-circuiting</em>. For <code>and</code>, your
interpreter should evaluate each sub-expression from left to right, and if any
of these evaluates to a false value, then <code>False</code> is returned.  If all but the
last sub-expressions evaluate to true values, return the last sub-expression
from <code>do_and_form</code>.</p>

<p>For <code>or</code>, evaluate each sub-expression from left to right. If any evaluates to
a true value, then <strong><code>quote</code> that value and return it</strong>. The return value must
be quoted because it will be evaluated as an expression in <code>scheme_eval</code>.  If
all but the last sub-expression evaluate to a false value, return the last
sub-expression from <code>do_or_form</code> without quoting it.</p>

<pre><code>scm&gt; (and)
True
scm&gt; (or)
False
scm&gt; (and 4 5 6)  ; all operands are true values
6
scm&gt; (or 5 2 1)  ; 5 is a true value
5
scm&gt; (and #t #f 42 (/ 1 0))  ; short-circuiting behavior of and
False
scm&gt; (or 4 #t (/ 1 0))  ; short-circuiting behavior of or
4</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 14 -u
python3 ok -q 14 -i</code></pre>


<h4 id="problem-15a-1-pt">Problem 15A (1 pt)</h4>

<p>Implement <code>do_cond_form</code> so that it returns the first result sub-expression
corresponding to a true predicate, or the sub-expression corresponding to
<code>else</code>. Your implementation should match the following examples and the
additional tests in <code>tests.scm</code>.</p>

<pre><code>scm&gt; (cond ((= 4 3) 'nope)
           ((= 4 4) 'hi)
           (else 'wait))
hi
scm&gt; (cond ((= 4 3) 'wat)
           ((= 4 4))
           (else 'hm))
True
scm&gt; (cond ((= 4 4) 'here 42)
           (else 'wat 0))
42</code></pre>

<p>For the last example, where the body of a <code>cond</code> case has multiple expressions,
you might find it helpful to replace <code>cond</code>-bodies with multiple expression
bodies into a single <code>begin</code> expression, i.e., the following two expressions are
equivalent.</p>

<pre><code>(cond ((= 4 4) 'here 42))
(cond ((= 4 4) (begin 'here 42)))</code></pre>

<p>If the body of a <code>cond</code> case is empty, then <code>do_cond_form</code> should quote the
value of the predicate and return it, if the predicate evaluates to a true
value.</p>

<pre><code>scm&gt; (cond (12))
12
scm&gt; (cond ((= 4 3))
           ('hi))
hi</code></pre>

<p>The value of a <code>cond</code> is undefined if there are no true predicates and no
<code>else</code>. In such a case, <code>do_cond_form</code> should return <code>okay</code>.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 15 -u
python3 ok -q 15 -i</code></pre>


<h4 id="problem-16-2-pt">Problem 16 (2 pt)</h4>

<p>The <code>let</code> special form introduces local variables, giving them their initial
values. For example:</p>

<pre><code>scm&gt; (define x 'hi)
x
scm&gt; (define y 'bye)
y
scm&gt; (let ((x 42) (y (* 5 10)))
       (list x y))
(42 50)
scm&gt; (list x y)
(hi bye)</code></pre>

<p>Implement the <code>do_let_form</code> method to have this effect and test it, by adding
test cases to the top of <code>tests.scm</code>. Make sure your <code>let</code> correctly handles
multi-expression bodies:</p>

<pre><code>scm&gt; (let ((x 42)) x 1 2)
2</code></pre>

<p>A <code>let</code> form creates a new <code>Frame</code> (containing the <code>let</code> bindings) which
extends the <strong>current environment</strong> and evaluates the body of the <code>let</code> in this
new environment.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 16 -u
python3 ok -q 16 -i</code></pre>


<h4 id="problem-17-2-pt">Problem 17 (2 pt)</h4>

<p>Implement <code>do_mu_form</code> to evaluate the <code>mu</code> special form, a non-standard Scheme
expression type. A <code>mu</code> expression is similar to a <code>lambda</code> expression, but
evaluates to a <code>MuProcedure</code> instance that is <strong>dynamically scoped</strong>. The
<code>MuProcedure</code> class has been provided for you.</p>

<p>Additionally, complete <code>scheme_apply</code> to call <code>MuProcedure</code> procedures using
dynamic scoping.  Calling a <code>LambdaProcedure</code> uses lexical scoping: the parent
of the new call frame is the environment in which the procedure was <strong>defined</strong>.
Calling a <code>MuProcedure</code> created by a <code>mu</code> expression uses dynamic scoping:  the
parent of the new call frame is the environment in which the call expression was
<strong>evaluated</strong>.  As a result, a <code>MuProcedure</code> does not need to store an
environment as an instance attribute.  It can refer to names in the environment
from which it was called.</p>

<pre><code>scm&gt; (define f (mu (x) (+ x y)))
f
scm&gt; (define g (lambda (x y) (f (+ x x))))
g
scm&gt; (g 3 7)
13</code></pre>

<p>To test yourself, figure out what the expression <code>(g 3 7)</code> would evaluate to if
the function <code>f</code> were instead a lambda function.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 17 -u
python3 ok -q 17 -i</code></pre>

<p>Your Scheme interpreter implementation is now complete.  You should have been
adding tests to the top of <code>tests.scm</code> as you did each problem.  These tests
will be evaluated as part of your composition score for the project.</p>


<h2 id="part-iii-write-some-scheme">Part III: Write Some Scheme</h2>


<p>Not only is your Scheme interpreter itself a tree-recursive program, but it is
flexible enough to evaluate <em>other</em> recursive programs. Implement the following
procedures in Scheme in the <code>questions.scm</code> file.</p>


<h3 id="problem-18-1-pt">Problem 18 (1 pt)</h3>

<p>Implement the <code>zip</code> procedure, which takes in a list of pairs and converts it
into a pair of lists, where the first list contains all of the first elements
of the original pairs, and the second list contains all of the second elements.</p>

<p>The "pairs" in the input are well-formed two-element lists, not Scheme pairs.</p>

<pre><code>scm&gt; (zip '((1 2)))
((1) (2))
scm&gt; (zip '((1 2) (3 4) (5 6)))
((1 3 5) (2 4 6))</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 18 -u
python3 ok -q 18 -i</code></pre>


<h3 id="problem-19-1-pt">Problem 19 (1 pt)</h3>

<p>Implement the <code>list-partitions</code> procedure, which lists all of the ways to
partition a positive integer <code>total</code> into at most <code>max-pieces</code> pieces, where
all of the pieces are less than or equal to a positive integer <code>max-value</code>.</p>

<p><em>Hint</em>: Define a helper procedure to construct partitions.</p>

<p>The number 5 has 4 partitions using pieces up to a <code>max-value</code> of 3 and a
<code>max-pieces</code> of 4:</p>

<pre><code>3, 2          (two pieces)
3, 1, 1       (three pieces)
2, 2, 1       (three pieces)
2, 1, 1, 1    (four pieces)</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 19 -u
python3 ok -q 19 -i</code></pre>


<h3 id="problem-20-2-pt">Problem 20 (2 pt)</h3>

<p>In Scheme, source code is data. Every non-primitive expression is a
list, and we can write procedures that manipulate other programs just as we
write procedures that manipulate lists.</p>

<p>Re-writing programs can be useful: we can write an interpreter that only
handles a small core of the language, and then write a procedure <code>analyze</code> that
converts other special forms into the core language before a program is passed
to the interpreter.</p>

<p>For example, the <code>let</code> special form is equivalent to a call expression that
begins with a <code>lambda</code> expression. Both create a new frame extending the
current environment and evaluate a body within that new environment.</p>

<pre><code>(let ((x 42) (y 16)) (+ x y))
;; Is equivalent to:
((lambda (x y) (+ x y)) 42 16)</code></pre>

<p>We can use this rule to rewrite all <code>let</code> special forms into <code>lambda</code>
expressions. We prevent evaluation of a program by quoting it, and then pass it
to <code>analyze</code>:</p>

<pre><code>scm&gt; (analyze '(let ((a 1) (b 2)) (+ a b)))
((lambda (a b) (+ a b)) 1 2)
scm&gt; (analyze '(let ((a 1)) (let ((b a)) b)))
((lambda (a) ((lambda (b) b) a)) 1)</code></pre>

<p>In order to handle all programs, <code>analyze</code> must be aware of Scheme syntax.
Since Scheme expressions are recursively nested, <code>analyze</code> must also be
recursive. In fact, the structure of <code>analyze</code> looks like that of
<code>scheme_eval</code>:</p>

<pre><code>(define (analyze expr)
  (cond ((atom?   expr) &lt;Analyze atom&gt;)
        ((quoted? expr) &lt;Analyze quoted&gt;)
        ((lambda? expr) &lt;Analyze lambda&gt;)
        ((define? expr) &lt;Analyze define&gt;)
        ((let?    expr) &lt;Analyze let&gt;)
        (else           &lt;Analyze other&gt;)))</code></pre>

<p>Implement the <code>analyze</code> procedure, which takes in an expression and converts
all of the <code>let</code> special forms in the expression into their equivalent <code>lambda</code>
expressions.</p>

<p><em>Hint</em>: You may want to use the provided <code>apply-to-all</code> procedure and the 'zip'
procedure from Q18.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 20 -u
python3 ok -q 20 -i</code></pre>

<p><em>Note</em>: We used <code>let</code> while defining <code>analyze</code>. What if we want to run
<code>analyze</code> on an interpreter that does not recognize <code>let</code>? We can pass
<code>analyze</code> to itself to <em>compile</em> itself into an equivalent program that does
not use <code>let</code>:</p>

<pre><code>;; The analyze procedure
(define (analyze expr)
  ...)

;; A list representing the analyze procedure
(define analyze-code
  '(define (analyze expr)
     ...))

;; An analyze procedure that does not use 'let'
(define analyze-without-let
  (analyze analyze-code))</code></pre>


<h3 id="problem-21-0-pt-optional">Problem 21 (0 pt; <em>optional</em>)</h3>

<p>Implement the <code>hax</code> procedure that draws the following recursive illustration
when passed two arguments, a side length <code>d</code> and recursive depth <code>k</code>.  The
example below is drawn from <code>(hax 200 4)</code>.</p>

<p><img src="hax.png" alt="hax"></p>

<p>To see how this illustration is constructed, consider this annotated version
that gives the relative lengths of lines of the component shapes in the figure.</p>

<p><img src="h1.png" alt="hax_annotated"></p>


<h2 id="part-iv-extra">Part IV: Extra</h2>



<h3 id="extra-credit-problem-22-2-pt">Extra Credit Problem 22 (2 pt)</h3>

<p>Complete the function <code>scheme_optimized_eval</code> in <code>scheme.py</code>. This alternative
to <code>scheme_eval</code> is properly tail recursive. That is, the interpreter will
allow an unbounded number of active <a href="http://en.wikipedia.org/wiki/Tail_call">tail
calls</a> in constant space.</p>

<p>Instead of recursively calling <code>scheme_eval</code> for tail calls, logical special
forms, and <code>let</code>, replace the current <code>expr</code> and <code>env</code> with different
expressions and environments. For call expressions, this change only applies to
calling user-defined procedures.</p>

<p>Once you finish, uncomment the following line in <code>scheme.py</code>:</p>

<pre><code>scheme_eval = scheme_optimized_eval</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok -q 22 -u
python3 ok -q 22 -i</code></pre>

<p><strong>Congratulations!</strong> You have finished the final project for 61A! Assuming your
tests are good and you've passed them all, consider yourself a proper computer
scientist!</p>

<p>Now, get some sleep. You've earned it!</p>


<h3 id="recursive-art-contest">Recursive Art Contest</h3>


<p>We've added a number of primitive drawing procedures that are collectively
called "turtle graphics".  The <em>turtle</em> represents the state of the drawing
module, which has a position, an orientation, a pen state (up or down), and a
pen color. The <code>tscheme__x_</code> functions in <code>scheme_primitives.py</code> are the
implementations of these procedures, and show their parameters with a brief
description of each.</p>

<p>The Python <a href="http://docs.python.org/release/3.2/library/turtle.html">documentation of the turtle
module</a> contains more
detail.</p>

<p><strong>Contest</strong>: Create a visualization of an iterative or recursive process of your
choosing, using turtle graphics. Your implementation must be written entirely in
Scheme using the interpreter you have built. However, you may add primitive
procedures to interface with Python's <code>turtle</code> or <code>math</code> modules. Other than
that <em>all computation must be done in Scheme</em>. If you do add new primitives,
then make sure to submit <code>scheme_primitives.py</code> in addition to <code>contest.scm</code>.</p>

<p>Prizes, as well as <strong>3 extra credit points</strong>, will be awarded for the winning
entry in each of the following categories.</p>

<p>Entries (code and results) will be posted online, and winners will be selected
by popular vote as part of a future homework.  The voting instructions will
read:</p>

<blockquote><p>Please vote for your favorite entry in this semester's 61A Recursion
Exposition contest.  The winner should exemplify the principles of elegance,
beauty, and abstraction that are prized in the Berkeley computer science
curriculum. As an academic community, we should strive to recognize and
reward merit and achievement (translation: please don't just vote for your
friends).</p></blockquote>

<p>To improve your chance of success, you are welcome to include a title and
descriptive <a href="http://en.wikipedia.org/wiki/Haiku">haiku</a> in the comments of your
entry, which will be included in the voting.</p>

<p>Entries that do not construct an image iteratively or recursively may be
disqualified. This includes just drawing a preexisting image, even if the
drawing function is iterative or recursive.</p>

<p><a href="../scheme_contest/index.html">Submission instructions</a> are posted.</p>


<h3 id="extra-challenge">Extra Challenge</h3>


<p>We have implemented a significant subset of Scheme in this project, but our
interpreter can be extended with more features by following the <a href="extensions.html">extension
instructions</a>.</p>


  

  

</body>